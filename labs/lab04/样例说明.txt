   （Ⅰ）任务：

        编写一个cache模拟器，该模拟器可以模拟在一系列的数据访问中cache的命中、不命中与牺牲行的情况，其中，需要牺牲行时，用LRU替换策略进行替换。

        cache模拟器需要能处理一系列如下的命令：

        Usage: ./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>

        其中各参数意义如下：

①-h：输出帮助信息的选项；

②-v：输出详细运行过程信息的选项；

③-s：组索引的位数(意味着组数S=2^s)；

④-E：每一组包含的行数；

⑤-b：偏移位的宽度(意味着块的大小为B=2^b);

⑥-t：输入数据文件的路径(测试数据从该文件里面读取)。

 

测试数据说明：
traces文件夹里面包含五个文件：



这五个文件就是用于测试csim.c的输入文件，各个文件中包含了各种不同指令，用于测试hits、missses、evictons。

trace文件中的指令具有如下形式：

I 0400d7d4,8

M 0421c7f0,4

L 04f6b868,8

S 7ff0005c8,8

即每行代表一个或两个内存访问。每行的格式是

[空格]操作 地址，大小

操作字段表示存储器访问的类型，其中：

“I”表示指令加载，

“L”表示数据加载，

“S”表示数据存储，

“M”表示数据修改（即数据存储之后的数据加载）。

每个“I”前面都没有空格。每个“M”，“L”和“S”之前总是有空格。

地址字段指定一个32位的十六进制存储器地址。

大小字段指定操作访问的字节数；

通俗地解释一下各种操作：

①对于‘I’指定地操作，实验说明中提到，我们不需要考虑：

意思就是valgrind运行地时候第一个指令总是为操作‘I’。

②对于‘L’以及‘S’指定的操作，我们简单地可以认为这两个操作都是对某一个地址寄存器进行访问（读取或者存入数据）；

③对于‘M’指定的操作，可以看作是对于同一地址连续进行‘L‘和’S‘操作。

以yi.trace中的数据为例：



其解释如下：

①对于地址0x10进行访问：

0x10=0000...00010000，偏移值为最低四位，故S=1;

访问结果为mis;

②连续对地址0x20进行连续两次访问：

0x20=000...00100000，S=2;

结果为第一次mis，第二次hit；

③对地址0x22进行访问：

0x22=000...00100100，S=2;

由于操作②以将该块存入高速缓存，故结果为hit;

④对地址0x18进行访问：

0x18=000...00011000，S=1;

由于操作①以将该块存入高速缓存，故结果为hit;

⑤对地址0x110进行访问：

0x110=0...000100010000，S=1;

虽然操作①使得第一组(只有一行有效)，但是这里的标志位的值Tag为1

故结果为先mis，后eviction;

⑥对地址0x210进行访问：

0x210=0...001000010000，S=1;

同操作⑤，但是这里的标志位的值为2，不匹配

故结果为先mis，后evicton;

⑦对地址0x12进行连续两次访问：

0x12=000...00000010010，S=1;

由于标志位不匹配，故第一次访问时mis，并evicton

第二次访问时当然就是hit。

上述分析也就是解释了实验说明中的示例

https://blog.csdn.net/xbb224007/article/details/81103995